# -*- coding: utf-8 -*-
"""machine learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hmcpd2Uj1PSOe01RJoEz5-WZagt9rY-V
"""

import numpy as np

def relu(x):
    return np.maximum(0, x)

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
    return x * (1 - x)

def relu_derivative(x):
    return np.where(x > 0, 1, 0)

def forward_pass(inputs, weights_hidden1, biases_hidden1, weights_hidden2, biases_hidden2, weights_output, biases_output):

    z_hidden1 = np.dot(weights_hidden1, inputs) + biases_hidden1
    a_hidden1 = relu(z_hidden1)

    z_hidden2 = np.dot(weights_hidden2, a_hidden1) + biases_hidden2
    a_hidden2 = relu(z_hidden2)

    z_output = np.dot(weights_output, a_hidden2) + biases_output
    output = sigmoid(z_output)

    return a_hidden1, a_hidden2, output

def backward_pass(inputs, a_hidden1, a_hidden2, output, target,
                  weights_output, weights_hidden2, weights_hidden1,
                  biases_output, biases_hidden2, biases_hidden1, learning_rate):

    out_error = output - target
    d_output = out_error * sigmoid_derivative(output)

    d_weights_output = np.dot(d_output, a_hidden2.T)
    d_biases_output = d_output

    hidden2_error = np.dot(weights_output.T, d_output)
    d_hidden2 = hidden2_error * relu_derivative(a_hidden2)
    d_weights_hidden2 = np.dot(d_hidden2, a_hidden1.T)
    d_biases_hidden2 = d_hidden2

    hidden1_error = np.dot(weights_hidden2.T, d_hidden2)
    d_hidden1 = hidden1_error * relu_derivative(a_hidden1)
    d_weights_hidden1 = np.dot(d_hidden1, inputs.T)
    d_biases_hidden1 = d_hidden1

    weights_output -= learning_rate * d_weights_output
    biases_output -= learning_rate * d_biases_output
    weights_hidden2 -= learning_rate * d_weights_hidden2
    biases_hidden2 -= learning_rate * d_biases_hidden2
    weights_hidden1 -= learning_rate * d_weights_hidden1
    biases_hidden1 -= learning_rate * d_biases_hidden1

    return weights_hidden1, biases_hidden1, weights_hidden2, biases_hidden2, weights_output, biases_output

np.random.seed(0)
inputs = np.random.rand(3, 1)
weights_hidden1 = np.random.rand(4, 3)
biases_hidden1 = np.random.rand(4, 1)

weights_hidden2 = np.random.rand(3, 4)
biases_hidden2 = np.random.rand(3, 1)

weights_output = np.random.rand(1, 3)
biases_output = np.random.rand(1, 1)

target = np.array([[1]])
learning_rate = 0.01

for time in range(10000):

    a_hidden1, a_hidden2, output = forward_pass(inputs, weights_hidden1, biases_hidden1, weights_hidden2, biases_hidden2, weights_output, biases_output)

    loss = np.mean((output - target) ** 2)
    if time % 100 == 0:
        print(f"Time {time}, Loss: {loss}")

    weights_hidden1, biases_hidden1, weights_hidden2, biases_hidden2, weights_output, biases_output = backward_pass(
        inputs, a_hidden1, a_hidden2, output, target, weights_output, weights_hidden2, weights_hidden1,
        biases_output, biases_hidden2, biases_hidden1, learning_rate
    )



